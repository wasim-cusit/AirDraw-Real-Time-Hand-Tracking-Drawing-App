
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>AirDraw â€” Fullscreen Hand Tracking</title>
<style>
  html, body {
    margin: 0; padding: 0;
    height: 100%; background: black;
    overflow: hidden;
  }
  video, canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  #controls {
    position: fixed;
    bottom: 10px; left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.5);
    padding: 8px;
    border-radius: 12px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    z-index: 10;
  }
  #controls input[type=color] {
    width: 40px; height: 40px; border: none;
  }
  #controls input[type=range] {
    width: 100px;
  }
  #controls button {
    background: #333; color: white;
    border: none; padding: 8px 14px;
    font-size: 16px; cursor: pointer;
    border-radius: 8px;
    min-width: 70px;
  }
</style>
</head>
<body>

<video id="input" playsinline></video>
<canvas id="overlay"></canvas>
<canvas id="ink"></canvas>

<div id="controls">
  <input type="color" id="color" value="#ff2d55" />
  <input type="range" id="size" min="2" max="20" value="6" />
  <button id="undoBtn">Undo</button>
  <button id="clearBtn">Clear</button>
  <button id="saveBtn">Save</button>
  <button><a href="./camera.html">New Camera</a></button>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

<script>
(async function(){
  const video = document.getElementById('input');
  const overlay = document.getElementById('overlay');
  const ink = document.getElementById('ink');
  const octx = overlay.getContext('2d');
  const ictx = ink.getContext('2d');

  const colorEl = document.getElementById('color');
  const sizeEl = document.getElementById('size');
  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const saveBtn = document.getElementById('saveBtn');

  let strokes = [];
  let currentStroke = null;
  let lastPos = null;
  let drawing = false;

  function resizeCanvas(){
    overlay.width = window.innerWidth;
    overlay.height = window.innerHeight;
    ink.width = window.innerWidth;
    ink.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  function toCanvasCoords(norm) {
    return {
      x: norm.x * overlay.width,
      y: norm.y * overlay.height
    };
  }

  function pinchActive(landmarks) {
    const t = landmarks[4];
    const i = landmarks[8];
    const dx = t.x - i.x;
    const dy = t.y - i.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    return dist < 0.06;
  }

  function drawLine(p1, p2, color, size) {
    ictx.strokeStyle = color;
    ictx.lineWidth = size;
    ictx.lineCap = "round";
    ictx.beginPath();
    ictx.moveTo(p1.x, p1.y);
    ictx.lineTo(p2.x, p2.y);
    ictx.stroke();
  }

  undoBtn.onclick = () => {
    strokes.pop();
    redrawAll();
  };
  clearBtn.onclick = () => {
    strokes = [];
    ictx.clearRect(0,0,ink.width,ink.height);
  };
  saveBtn.onclick = () => {
    const link = document.createElement('a');
    const merged = document.createElement('canvas');
    merged.width = ink.width;
    merged.height = ink.height;
    const mctx = merged.getContext('2d');
    mctx.drawImage(video, 0, 0, merged.width, merged.height);
    mctx.drawImage(ink, 0, 0);
    link.href = merged.toDataURL("image/png");
    link.download = "airdraw.png";
    link.click();
  };

  function redrawAll(){
    ictx.clearRect(0,0,ink.width,ink.height);
    for (const s of strokes) {
      for (let i = 1; i < s.points.length; i++) {
        drawLine(s.points[i-1], s.points[i], s.color, s.size);
      }
    }
  }

  function drawHandSkeleton(lm){
    octx.lineWidth = 2;
    octx.strokeStyle = "rgba(0,255,255,0.6)";
    octx.fillStyle = "rgba(255,255,0,0.9)";
    // Draw connections
    const fingers = [
      [0,1,2,3,4],
      [0,5,6,7,8],
      [0,9,10,11,12],
      [0,13,14,15,16],
      [0,17,18,19,20]
    ];
    fingers.forEach(f=>{
      for(let i=0;i<f.length-1;i++){
        const p1 = toCanvasCoords(lm[f[i]]);
        const p2 = toCanvasCoords(lm[f[i+1]]);
        octx.beginPath();
        octx.moveTo(p1.x, p1.y);
        octx.lineTo(p2.x, p2.y);
        octx.stroke();
      }
    });
    // Draw points
    lm.forEach((pt, index) => {
      const pos = toCanvasCoords(pt);
      octx.beginPath();
      octx.arc(pos.x, pos.y, index===8 || index===4 ? 6 : 4, 0, Math.PI*2);
      octx.fill();
    });
  }

  const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
  });

  hands.onResults((results)=>{
    octx.clearRect(0,0,overlay.width,overlay.height);

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
      const lm = results.multiHandLandmarks[0];
      const tip = toCanvasCoords(lm[8]);

      // Draw hand skeleton and points
      drawHandSkeleton(lm);

      // Drawing
      if (pinchActive(lm)) {
        if (!drawing) {
          drawing = true;
          currentStroke = { color: colorEl.value, size: parseInt(sizeEl.value), points: [tip] };
          strokes.push(currentStroke);
        } else {
          currentStroke.points.push(tip);
          if (lastPos) drawLine(lastPos, tip, currentStroke.color, currentStroke.size);
        }
      } else {
        drawing = false;
        currentStroke = null;
      }
      lastPos = tip;
    } else {
      drawing = false;
      currentStroke = null;
      lastPos = null;
    }
  });

  const camera = new Camera(video, {
    onFrame: async () => { await hands.send({image: video}); },
    width: window.innerWidth,
    height: window.innerHeight
  });

  navigator.mediaDevices.getUserMedia({
    video: {
      facingMode: "user",
      width: { ideal: 1920 },
      height: { ideal: 1080 }
    }
  }).then(stream => {
    video.srcObject = stream;
    video.play();
    camera.start();
  }).catch(err => {
    alert("Camera error: " + err);
  });
})();
</script>
</body>
</html>
