<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
<title>AirDraw — Fullscreen Hand Tracking</title>
<style>
:root {
  --panel-bg: rgba(15, 23, 42, 0.7);
  --panel-border: rgba(255,255,255,0.12);
  --text: #e5e7eb;
  --muted: #94a3b8;
  --accent: #7c3aed;
}
* { box-sizing: border-box; }
html, body { margin:0; padding:0; height:100%; background:#0b1220; color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
#stage { position:fixed; inset:0; width:100vw; height:100vh; background:#000; overflow:hidden; touch-action:none; }
video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; touch-action:none; }
.hud { position:absolute; left:12px; right:12px; bottom:env(safe-area-inset-bottom,12px); display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:center; z-index:10; pointer-events:none; }
.pill, .btn { pointer-events:auto; background:var(--panel-bg); border:1px solid var(--panel-border); backdrop-filter:blur(10px); color:var(--text); border-radius:12px; }
.pill { display:flex; align-items:center; gap:10px; padding:8px 10px; flex-wrap:wrap; }
.btn { padding:10px 14px; cursor:pointer; user-select:none; }
.btn:active { transform:translateY(1px); }
.pill label { font-size:12px; color:var(--muted); }
input[type="color"]{width:36px;height:36px;border:none;border-radius:8px;background:transparent;}
input[type="range"]{width:110px;}
.tagbar{position:absolute; top:10px; left:10px; display:flex; gap:8px; flex-wrap:wrap; align-items:center; z-index:10;}
.tag{background:var(--panel-bg); border:1px solid var(--panel-border); padding:6px 10px; border-radius:999px; font-size:12px; color:var(--muted);}
#startGate{position:absolute; inset:0; display:grid; place-items:center; background:linear-gradient(180deg, rgba(124,58,237,.2), rgba(2,6,23,.9)); z-index:20;}
#startGate .card{background:rgba(2,6,23,.85); border:1px solid var(--panel-border); padding:18px; border-radius:14px; text-align:center; max-width:360px;}
#startGate h1{margin:0 0 8px; font-size:18px;}
#startGate p{margin:0 0 14px; color:var(--muted); font-size:13px;}
#startBtn{background:var(--accent); border:none; color:white; padding:10px 16px; border-radius:10px; cursor:pointer;}
.topright{position:absolute; top:12px; right:12px; z-index:15;}
.topright .btn{pointer-events:auto;}
@media(max-width:768px){ input[type="range"]{width:140px;} .btn{padding:12px 16px;} }
</style>
</head>
<body>
<div id="stage">
  <video id="video" playsinline autoplay muted></video>
  <canvas id="overlay"></canvas>
  <canvas id="ink"></canvas>

  <div id="startGate">
    <div class="card">
      <h1>AirDraw</h1>
      <p>Tap start, allow camera access, then <b>pinch thumb + index</b> to draw in the air.</p>
      <button id="startBtn">Start Camera</button>
    </div>
  </div>

  <div class="tagbar">
    <div class="tag">Pinch to draw</div>
    <div class="tag"><span id="fps">FPS: —</span></div>
    <div class="tag" id="status">Loading…</div>
  </div>

  <div class="topright">
    <button class="btn"><a href="./camera.html" style="color:inherit;text-decoration:none;">New Camera</a></button>
  </div>

  <div class="hud">
    <div class="pill">
      <label>Color</label><input id="color" type="color" value="#7c3aed">
      <label>Size</label><input id="size" type="range" min="2" max="24" value="6">
      <label>Smooth</label><input id="smooth" type="checkbox" checked>
      <label>Mirror</label><input id="mirror" type="checkbox" checked>
    </div>
    <button class="btn" id="undoBtn" title="Undo (U)">Undo</button>
    <button class="btn" id="clearBtn" title="Clear (C)">Clear</button>
    <button class="btn" id="saveBtn" title="Save (S)">Save</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script>
(() => {
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const ink = document.getElementById('ink');
const octx = overlay.getContext('2d');
const ictx = ink.getContext('2d');

const startGate = document.getElementById('startGate');
const startBtn = document.getElementById('startBtn');
const colorEl = document.getElementById('color');
const sizeEl = document.getElementById('size');
const smoothEl = document.getElementById('smooth');
const mirrorEl = document.getElementById('mirror');
const undoBtn = document.getElementById('undoBtn');
const clearBtn = document.getElementById('clearBtn');
const saveBtn = document.getElementById('saveBtn');
const fpsEl = document.getElementById('fps');
const statusEl = document.getElementById('status');

let strokes = [], currentStroke = null, lastPoint = null, isDrawing = false;
let frames = 0, lastT = performance.now();
const SMOOTHING_FACTOR = 0.4; // Lower values = more smoothing
let smoothedPoint = null;

function resizeAll(){
  const w = window.innerWidth, h = window.innerHeight;
  const dpr = window.devicePixelRatio || 1;
  overlay.width = w*dpr; overlay.height = h*dpr; overlay.style.width = w+'px'; overlay.style.height = h+'px';
  ink.width = w*dpr; ink.height = h*dpr; ink.style.width = w+'px'; ink.style.height = h+'px';
  octx.setTransform(1,0,0,1,0,0); ictx.setTransform(1,0,0,1,0,0);
  octx.scale(dpr,dpr); ictx.scale(dpr,dpr);
}
window.addEventListener('resize', resizeAll);
window.addEventListener('orientationchange', ()=>setTimeout(resizeAll,50));
resizeAll();

function tickFPS(){ frames++; const now=performance.now(); if(now-lastT>=1000){ fpsEl.textContent=`FPS: ${frames}`; frames=0; lastT=now; } }
function applyMirror(){ video.style.transform = mirrorEl.checked?'scaleX(-1)':'scaleX(1)'; }
mirrorEl.addEventListener('change', applyMirror); applyMirror();

function toCanvasXY(norm){
  let x = norm.x * window.innerWidth;
  let y = norm.y * window.innerHeight;
  if(mirrorEl.checked) x = window.innerWidth - x;
  return {x,y};
}

function isPinching(landmarks){
  const thumbTip = landmarks[4];
  const indexTip = landmarks[8];
  const dist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
  return dist < 0.05; // Threshold for pinch detection
}

function drawHandSkeleton(landmarks) {
  // Draw connections between landmarks
  const connections = [
    [0, 1, 2, 3, 4],       // Thumb
    [0, 5, 6, 7, 8],       // Index
    [0, 9, 10, 11, 12],    // Middle
    [0, 13, 14, 15, 16],   // Ring
    [0, 17, 18, 19, 20]    // Pinky
  ];
  
  octx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
  octx.lineWidth = 2;
  
  connections.forEach(finger => {
    for (let i = 0; i < finger.length - 1; i++) {
      const start = toCanvasXY(landmarks[finger[i]]);
      const end = toCanvasXY(landmarks[finger[i + 1]]);
      octx.beginPath();
      octx.moveTo(start.x, start.y);
      octx.lineTo(end.x, end.y);
      octx.stroke();
    }
  });
  
  // Draw landmarks
  octx.fillStyle = 'rgba(255, 255, 0, 0.9)';
  landmarks.forEach((landmark, i) => {
    const pos = toCanvasXY(landmark);
    octx.beginPath();
    octx.arc(pos.x, pos.y, i === 8 || i === 4 ? 6 : 4, 0, Math.PI * 2);
    octx.fill();
  });
}

function redrawAll(){
  ictx.clearRect(0,0,ink.width,ink.height);
  ictx.lineCap='round'; 
  ictx.lineJoin='round';
  
  strokes.forEach(stroke => {
    if (stroke.points.length < 2) return;
    
    ictx.beginPath();
    ictx.strokeStyle = stroke.color;
    ictx.lineWidth = stroke.size;
    
    ictx.moveTo(stroke.points[0].x, stroke.points[0].y);
    for (let i = 1; i < stroke.points.length; i++) {
      ictx.lineTo(stroke.points[i].x, stroke.points[i].y);
    }
    
    ictx.stroke();
  });
}

undoBtn.onclick = () => { 
  strokes.pop(); 
  redrawAll(); 
  statusEl.textContent = 'Undo last stroke';
  setTimeout(() => {
    if (strokes.length === 0) statusEl.textContent = 'Show your hand to the camera';
  }, 2000);
};

clearBtn.onclick = () => { 
  strokes = []; 
  redrawAll(); 
  statusEl.textContent = 'Canvas cleared';
  setTimeout(() => {
    statusEl.textContent = 'Show your hand to the camera';
  }, 2000);
};

saveBtn.onclick = () => {
  const w = ink.width, h = ink.height;
  const tmp = document.createElement('canvas');
  tmp.width = w;
  tmp.height = h;
  const tctx = tmp.getContext('2d');
  
  // Draw video background
  tctx.drawImage(video, 0, 0, w, h);
  
  // Draw ink layer
  tctx.drawImage(ink, 0, 0);
  
  // Create download link
  const a = document.createElement('a');
  a.href = tmp.toDataURL('image/png');
  a.download = 'airdraw-' + new Date().toISOString().slice(0, 10) + '.png';
  a.click();
  
  statusEl.textContent = 'Image saved';
  setTimeout(() => {
    statusEl.textContent = 'Show your hand to the camera';
  }, 2000);
};

const hands = new Hands({ 
  locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` 
});

hands.setOptions({ 
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.6
});

hands.onResults(results => {
  tickFPS(); 
  octx.clearRect(0, 0, overlay.width, overlay.height);
  
  if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
    const landmarks = results.multiHandLandmarks[0];
    const indexTip = landmarks[8];
    const currentPoint = toCanvasXY(indexTip);
    
    // Apply smoothing if enabled
    if (smoothEl.checked) {
      if (!smoothedPoint) {
        smoothedPoint = { ...currentPoint };
      } else {
        smoothedPoint.x += SMOOTHING_FACTOR * (currentPoint.x - smoothedPoint.x);
        smoothedPoint.y += SMOOTHING_FACTOR * (currentPoint.y - smoothedPoint.y);
      }
    } else {
      smoothedPoint = { ...currentPoint };
    }
    
    // Draw hand skeleton
    drawHandSkeleton(landmarks);
    
    // Check for pinch gesture
    const pinching = isPinching(landmarks);
    
    if (pinching) {
      if (!isDrawing) {
        // Start new stroke
        isDrawing = true;
        currentStroke = {
          color: colorEl.value,
          size: parseInt(sizeEl.value),
          points: [smoothedPoint]
        };
        strokes.push(currentStroke);
        statusEl.textContent = 'Drawing...';
      } else {
        // Continue current stroke
        currentStroke.points.push(smoothedPoint);
        
        // Draw line segment
        ictx.beginPath();
        ictx.strokeStyle = currentStroke.color;
        ictx.lineWidth = currentStroke.size;
        ictx.lineCap = 'round';
        ictx.moveTo(lastPoint.x, lastPoint.y);
        ictx.lineTo(smoothedPoint.x, smoothedPoint.y);
        ictx.stroke();
      }
    } else {
      if (isDrawing) {
        // Finish current stroke
        isDrawing = false;
        currentStroke = null;
        statusEl.textContent = 'Hand detected';
      }
    }
    
    lastPoint = smoothedPoint;
  } else {
    // No hand detected
    isDrawing = false;
    currentStroke = null;
    statusEl.textContent = 'Show your hand to the camera';
  }
});

async function startCamera(){
  statusEl.textContent = 'Requesting camera...';
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ 
      video: {
        facingMode: 'user', 
        width: { ideal: 1280 }, 
        height: { ideal: 720 }
      }, 
      audio: false
    });
    
    video.srcObject = stream;
    await video.play();
    
    const mpCam = new Camera(video, { 
      onFrame: async () => { 
        resizeAll(); 
        await hands.send({ image: video }); 
      }, 
      width: 1280, 
      height: 720 
    });
    
    mpCam.start(); 
    startGate.style.display = 'none'; 
    statusEl.textContent = 'Camera OK — show your hand';
  } catch(err) { 
    console.error(err); 
    statusEl.textContent = 'Camera error'; 
    alert('Camera access failed: ' + err.message);
  }
}

startBtn.addEventListener('click', startCamera);

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.key.toLowerCase() === 'u') undoBtn.click();
  if (e.key.toLowerCase() === 'c') clearBtn.click();
  if (e.key.toLowerCase() === 's') saveBtn.click();
});
})();
</script>
</body>
</html>